#include "TopTagger/TopTagger/interface/TTMOpenCVMVA.h"

#include "TopTagger/TopTagger/interface/TopTaggerUtilities.h"
#include "TopTagger/TopTagger/interface/TopObject.h"
#include "TopTagger/TopTagger/interface/TopTaggerResults.h"
#include "TopTagger/CfgParser/include/Context.hh"
#include "TopTagger/CfgParser/include/CfgDocument.hh"
#include "TopTagger/CfgParser/include/TTException.h"

void TTMOpenCVMVA::getParameters(const cfg::CfgDocument* cfgDoc, const std::string& localContextName)
{
#ifdef SHOTTOPTAGGER_DO_OPENCV
    //Construct contexts
    cfg::Context commonCxt("Common");
    cfg::Context localCxt(localContextName);

    discriminator_ = cfgDoc->get("discCut",      localCxt, -999.9);
    modelFile_     = cfgDoc->get("modelFile",    localCxt, "");

    csvThreshold_  = cfgDoc->get("csvThreshold", localCxt, -999.9);
    bEtaCut_       = cfgDoc->get("bEtaCut",      localCxt, -999.9);
    maxNbInTop_    = cfgDoc->get("maxNbInTop",   localCxt, -1);

    std::string modelFileFullPath;
    if(workingDirectory_.size()) modelFileFullPath = workingDirectory_ + "/" + modelFile_;
    else                         modelFileFullPath = modelFile_;

    int iVar = 0;
    bool keepLooping;
    do
    {
        keepLooping = false;

        //Get variable name
        std::string varName = cfgDoc->get("mvaVar", iVar, localCxt, "");

        //if it is a non empty string save in vector
        if(varName.size() > 0)
        {
            keepLooping = true;

            vars_.push_back(varName);
        }
        ++iVar;
    }
    while(keepLooping);

    treePtr_ = cv::ml::RTrees::load<cv::ml::RTrees>(modelFileFullPath);
    if(treePtr_ == nullptr || treePtr_->empty())
    {
        //Throw if this is an invalid pointer
        THROW_TTEXCEPTION("Model file \"" + modelFile_ + "\" is not found or is invalid!!!");
    }

    //Checks that the loaded model file yields a valid trained model 
    if(!treePtr_->isTrained())
    {
        THROW_TTEXCEPTION("Model file \"" + modelFile_ + "\" yields untrained forest!!!");
    }

    //Check that the number of supplied variables matches the number expected in the model file
    if(vars_.size() != static_cast<unsigned int>(treePtr_->getVarCount()))
    {
        THROW_TTEXCEPTION("Incorrect number of variables specified!!! " + std::to_string(treePtr_->getVarCount()) + "expected " + std::to_string(vars_.size()) + " found.");
    }

    //load variables
    varCalculator_.reset(new ttUtility::TrijetInputCalculator());
    //map variables
    varCalculator_->mapVars(vars_);
    values_.resize(vars_.size());
    varCalculator_->setPtr(values_.data());

#else
    //Mark variables unused to suppress warnings
    (void)cfgDoc;
    (void)localContextName;
    THROW_TTEXCEPTION("Top tagger was not compiled with support for OpenCV!!!!"); 
#endif
}

void TTMOpenCVMVA::run(TopTaggerResults& ttResults)
{
#ifdef SHOTTOPTAGGER_DO_OPENCV
    //Get the list of top candidates as generated by the clustering algo
    std::vector<TopObject>& topCandidates = ttResults.getTopCandidates();
    //Get the list of final tops into which we will stick candidates
    std::vector<TopObject*>& tops = ttResults.getTops();

    for(auto& topCand : topCandidates)
    {
        //We only want to apply the MVA algorithm to triplet tops
        if(topCand.getNConstituents() == 3)
        {
            //Prepare data from top candidate (this code is shared with training tuple producer)
            //Perhaps one day the intermediate map can be bypassed ...
//            std::map<std::string, double> varMap = ttUtility::createMVAInputs(topCand, csvThreshold_);

            //Construct opencv data matrix for prediction
            cv::Mat inputData(vars_.size(), 1, 5); //the last 5 is for CV_32F var type

            if(varCalculator_->calculateVars(topCand, 0))
            {
                //populate opencv data matrix based on desired input variables 
                for(unsigned int i = 0; i < values_.size(); ++i)
                {
                    inputData.at<float>(i, 0) = values_[i];
                }
            
                //predict value
                double discriminator = treePtr_->predict(inputData);
                topCand.setDiscriminator(discriminator);

                //Check number of b-tagged jets in the top
                bool passBrequirements = maxNbInTop_ < 0 || topCand.getNBConstituents(csvThreshold_, bEtaCut_) <= maxNbInTop_;

                //place in final top list if it passes the threshold
                if(discriminator > discriminator_ && passBrequirements)
                {
                    tops.push_back(&topCand);
                }
            }
        }
    }
#else
    //Mark variables unused to suppress warnings
    (void)ttResults;
#endif
}
